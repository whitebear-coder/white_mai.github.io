<hr>
<p>title: 散列表、二叉搜索树、红黑树<br>tags: 算法<br>cover: /img/leetcode.png</p>
<h2 id="abbrlink-43814"><a href="#abbrlink-43814" class="headerlink" title="abbrlink: 43814"></a>abbrlink: 43814</h2><h1 id="散列表-Hash-Map"><a href="#散列表-Hash-Map" class="headerlink" title="散列表(Hash Map)"></a>散列表(Hash Map)</h1><ul>
<li><strong>直接寻址表</strong> 缺点:会浪费绝大部分空间</li>
<li><strong>散列表</strong>：将直接寻址得到的槽位置进行映射，映射的函数叫<strong>散列函数</strong><ul>
<li><strong>存在一个问题</strong> : 两个关键字可能映射到同一个槽中，我们称这种情况叫做 <strong>冲突</strong></li>
<li><strong>解决方法一</strong> ：链接法:  <strong>数组＋链表</strong> 的形式</li>
<li><strong>解决方法二</strong> :  开放寻址法<ul>
<li>开放寻址法中，所有的元素都存放在散列表里，每个表项或包含动态集合的一个元素或者NIL。当查找某个元素时，要系统的检查所有表项，直到找到所有的元素或者最终查明元素不在表中。</li>
<li>为了使用开放寻址法插入一个元素，需要连续的检查散列表，直到找到一个空槽来放置待插入的关键字为止，检查的顺序不一定是顺序序列，而是依赖于待插入的关键字</li>
<li><strong>开放寻址法的思想</strong> ：插入一个关键字k， 如果k被占用，则往后一个位置插入，直到没有空间，__与链接法相比，不需要指针，所以可以将指针所占用的空间存放更多的槽。</li>
<li><strong>开放寻址法的缺点 </strong>: 在于该方法的删除操作，如果删除了某个关键字后，无法检索到以后的关键字了，如果用一个特定的值代替，查找时间就不依赖于转载因子了</li>
<li>三种技术用来探查序列：<ul>
<li>线性探查</li>
<li>二次探查</li>
<li>双重散列</li>
</ul>
</li>
</ul>
</li>
<li><strong>散列函数的构造</strong> ：1. 除法散列法 2.乘法散列法</li>
</ul>
</li>
</ul>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><ul>
<li><strong>二叉搜索树的定义</strong>：树中的任意一个节点：二叉搜索树的左子节点小于等于该节点，右子节点大于等于该节点。</li>
<li>查询二叉搜索树：最大关键字元素和最小关键字元素</li>
<li><p><strong>_二叉搜索树的插入和删除操作_</strong>:</p>
<ul>
<li>插入操作<ul>
<li>插入值如果大于根节点值，插入右子树</li>
<li>插入值如果小于根节点值，插入左子树</li>
</ul>
</li>
<li><strong>删除操作</strong><ul>
<li>若删除的节点无左子树和右子树，直接删除。</li>
<li>若删除的节点只有左子树(右子树)，那么左子树(右子树)的根节点连上要删除节点的父亲</li>
<li>若删除的节点既有左子树又有右子树，有两种方式删除<ul>
<li>方式一：左子树的最大值nodeX, 与根节点的值互换(只是值互换)， 删除nodeX, 此时nodeX可能有左子树，则按照如上删除节点只有左子树的方式删除。</li>
<li>方式二：右子树的最小值nodeY, 与根节点的值互换(只是值互换)， 删除nodeY, 此时nodeY可能有右子树，则按照如上删除节点只有右子树的方式删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意区分二叉搜索树和完全二叉树的区别</p>
</li>
</ul>
